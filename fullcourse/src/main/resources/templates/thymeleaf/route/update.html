<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<div th:fragment="common_content(title)">
	<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
	<link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
	<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

	<html>

	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>simpleMap</title>
		<style>
			#sidebar {
				margin-top: 180px;
				width: 350px;
				height: 100%;
				background-color: #f2f2f2;
				padding: 20px;
				position: fixed;
				top: 0;
				left: 0;
				overflow-y: auto;
			}

			.savebutton {
				margin-left: 500px;
			}

			.ft_select_wrap {
				float: right;
			}

			.map_result {
				float: right;
			}

			/* 팝업 창 스타일 */
			.popup {
				display: none;
				position: fixed;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				background-color: white;
				padding: 20px;
				border: 1px solid black;
				border-radius: 5px;
				z-index: 1000;
			}

			/* 달력 스타일 */
			#calendar {
				display: none;
				position: absolute;
				background-color: #fff;
				border: 1px solid #ccc;
				padding: 10px;
				z-index: 1000;
			}


			/* sidebar 내의 각 여행지 정보를 스타일링하기 위한 스타일 */
			.sidebar-item {
				margin-bottom: 10px;
				cursor: pointer;
			}

			/* 작은 화면을 나타내는 div 요소의 스타일 */
			#smallScreen {
				display: none;
				/* 초기에는 숨겨짐 */
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				background-color: white;
				padding: 20px;
				border: 1px solid black;
				border-radius: 5px;
				z-index: 1000;
			}

			.day-marker {
				pointer-events: none;
			}

			#closeButton {
				padding: 5px 10px;
				/* 버튼의 패딩 */
				margin-left: 10px;
				/* 왼쪽 여백 */
				font-size: 14px;
				/* 폰트 크기 */
				color: #fff;
				/* 텍스트 색상 */
				background-color: #ff6347;
				/* 배경 색상 */
				border: none;
				/* 경계선 없음 */
				border-radius: 3px;
				/* 경계선 둥글게 */
				cursor: pointer;
				/* 커서 스타일 */
			}


			.delete-button {
				padding: 5px 10px;
				/* 버튼의 패딩 */
				margin-left: 10px;
				/* 왼쪽 여백 */
				font-size: 14px;
				/* 폰트 크기 */
				color: #fff;
				/* 텍스트 색상 */
				background-color: #ff6347;
				/* 배경 색상 */
				border: none;
				/* 경계선 없음 */
				border-radius: 3px;
				/* 경계선 둥글게 */
				cursor: pointer;
				/* 커서 스타일 */
			}

			.delete-button:hover {
				background-color: #e53e30;
				/* 호버 시 배경 색상 변경 */
			}

			.delete-button::before {
				content: "×";
			}

			.transport-buttons button {
				/* 일반 버튼 스타일 */
				background-color: rgb(232, 255, 223);
				color: rgb(0, 0, 0);
				/* 텍스트 색상 */
				padding: 10px 20px;
				/* 내부 여백 */
				border: none;
				/* 테두리 없음 */
				text-align: center;
				/* 텍스트 가운데 정렬 */
				text-decoration: none;
				/* 텍스트 밑줄 없음 */
				display: inline-block;
				font-size: 16px;
				/* 텍스트 크기 */
				margin: 4px 2px;
				/* 마진 */
				cursor: pointer;
				/* 커서 포인터로 변경 */
				border-radius: 8px;
				/* 버튼 모서리 둥글게 */
			}

			button {
				/* 일반 버튼 스타일 */
				background-color: rgb(232, 255, 223);
				color: rgb(0, 0, 0);
				/* 텍스트 색상 */
				padding: 10px 20px;
				/* 내부 여백 */
				border: none;
				/* 테두리 없음 */
				text-align: center;
				/* 텍스트 가운데 정렬 */
				text-decoration: none;
				/* 텍스트 밑줄 없음 */
				display: inline-block;
				font-size: 16px;
				/* 텍스트 크기 */
				margin: 4px 2px;
				/* 마진 */
				cursor: pointer;
				/* 커서 포인터로 변경 */
				border-radius: 8px;
				/* 버튼 모서리 둥글게 */
			}



			/* 초록색 버튼 스타일 */
			.green-button {
				background-color: #7ab730;
				/* 초록색 배경색 */
				color: white;
				/* 텍스트 색상 */
				padding: 10px 20px;
				/* 내부 여백 */
				border: none;
				/* 테두리 없음 */
				text-align: center;
				/* 텍스트 가운데 정렬 */
				text-decoration: none;
				/* 텍스트 밑줄 없음 */
				display: inline-block;
				font-size: 16px;
				/* 텍스트 크기 */
				margin: 4px 2px;
				/* 마진 */
				cursor: pointer;
				/* 커서 포인터로 변경 */
				border-radius: 8px;
				/* 버튼 모서리 둥글게 */
			}

			/* 파란색 버튼 스타일 */
			.blue-button {
				background-color: #008CBA;
				/* 파란색 배경색 */
				color: white;
				/* 텍스트 색상 */
				padding: 10px 20px;
				/* 내부 여백 */
				border: none;
				/* 테두리 없음 */
				text-align: center;
				/* 텍스트 가운데 정렬 */
				text-decoration: none;
				/* 텍스트 밑줄 없음 */
				display: inline-block;
				font-size: 16px;
				/* 텍스트 크기 */
				margin: 4px 2px;
				/* 마진 */
				cursor: pointer;
				/* 커서 포인터로 변경 */
				border-radius: 8px;
				/* 버튼 모서리 둥글게 */
			}

			.onebutton.blue-button {
				background-color: #008CBA;
				/* 파란색 배경색 */
				color: white;
				/* 텍스트 색상 */
				padding: 10px 20px;
				/* 내부 여백 */
				border: none;
				/* 테두리 없음 */
				text-align: center;
				/* 텍스트 가운데 정렬 */
				text-decoration: none;
				/* 텍스트 밑줄 없음 */
				display: inline-block;
				font-size: 16px;
				/* 텍스트 크기 */
				margin: 4px 2px;
				/* 마진 */
				cursor: pointer;
				/* 커서 포인터로 변경 */
				border-radius: 8px;
				/* 버튼 모서리 둥글게 */
			}

			.onebutton.green-button {
				background-color: #7ab730;
				/* 초록색 배경색 */
				color: white;
				/* 텍스트 색상 */
				padding: 10px 20px;
				/* 내부 여백 */
				border: none;
				/* 테두리 없음 */
				text-align: center;
				/* 텍스트 가운데 정렬 */
				text-decoration: none;
				/* 텍스트 밑줄 없음 */
				display: inline-block;
				font-size: 16px;
				/* 텍스트 크기 */
				margin: 4px 2px;
				/* 마진 */
				cursor: pointer;
				/* 커서 포인터로 변경 */
				border-radius: 8px;
				/* 버튼 모서리 둥글게 */
			}

			/* 작은 화면을 나타내는 div 요소의 스타일 */
			#addTourScreen {
				display: none;
				/* 초기에는 숨겨짐 */
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				background-color: white;
				padding: 20px;
				border: 1px solid black;
				border-radius: 5px;
				z-index: 1000;
			}

			#button_container {

				position: absolute;
				top: 20px;
				/* 버튼을 지도 상단에서 20px 아래로 배치합니다. */
				left: -460px;
				/* 버튼을 지도 오른쪽에서 20px 왼쪽으로 배치합니다. */
				z-index: 1000;
				/* 다른 요소 위에 배치합니다. */
			}


			#button_container button {
				padding: 10px 20px;
				background-color: #7ab730;
				/* 밝은 파란색 */
				color: white;
				border: none;
				border-radius: 5px;
				box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
				transition: all 0.3s ease;
				/* 부드러운 전환 효과 */
				font-size: 16px;
				cursor: pointer;
			}

			#addToSidebarButton {
				padding: 10px 20px;
				background-color: #7ab730;
				/* 밝은 파란색 */
				color: white;
				border: none;
				border-radius: 5px;
				box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
				transition: all 0.3s ease;
				/* 부드러운 전환 효과 */
				font-size: 16px;
				cursor: pointer;
			}
		</style>
		<script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
		<script
			src="https://apis.openapi.sk.com/tmap/jsv2?version=1&appKey=6VYbMDkEY24DlbC0m8ymh1ESimWVROyI3sP7PqT1"></script>

		<script th:inline="javascript">
			var routes = /*[[${(routes)}]]*/[];
			var routeUserId = /*[[${(routeUserId)}]]*/[];
		</script>

		<script type="text/javascript">

			var map;
			//자동차 경로 안
			var markerInfo;
			//출발지,도착지 마커
			var marker_s, marker_e, marker_p;
			//경로그림정보
			var drawInfoArr = [];
			var drawInfoArr2 = [];

			var chktraffic = [];
			var resultdrawArr = [];  //라인 
			var resultMarkerArr = [];

			//자동차, 도보 
			var selectedTransportMode = "";
			// Tmap api를 통한 경로의 거리와 이동 시간을 담을 객체.  
			var transportData = {};

			// 여행 일정 저장 객체
			let itinerary = [];
			var user1 = "user1";


			var map, marker;
			var lonlat;
			var markers = [];
			var addTourEnabled = false; // 전역 변수로 선언합니다.
			var newPlaces = [];

			var routeName;

			// 페이지가 로딩이 된 후 호출하는 함수입니다.
			function initTmap() {

				var screenWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
				var screenHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

				// map 생성
				// Tmapv2.Map을 이용하여, 지도가 들어갈 div, 넓이, 높이를 설정합니다.
				map = new Tmapv2.Map("map_div", { // 지도가 생성될 div
					center: new Tmapv2.LatLng(routes[0].routeStartLatitude, routes[0].routeStartLongitude),
					width: "1350px", // 지도의 넓이
					height: "1500px", // 지도의 높이
					zoom: 10
				});


				// DB에서 가져온 여행지 정보
				$.ajax({
					url: '/route/gettour',
					type: 'GET',
					dataType: 'json',
					success: function (data) {
						// 가져온 데이터를 places 변수에 할당
						var places = data;

						// places 변수를 이용하여 원하는 작업을 수행
						//여행지 마커 생성 및 추가
						places.forEach(function (place) {

							var marker = new Tmapv2.Marker({
								position: new Tmapv2.LatLng(place.lattitue, place.longtitue),
								map: map,
								title: place.name
							});
							// Marker에 클릭 이벤트 등록
							marker.addListener("click", function (evt) {
								showSmallScreen(place);
							});
						});
					}
				})

				displayRoutes(routes);

				var sidebar = document.getElementById('sidebar');
				var smallScreen = document.getElementById('smallScreen');
				var addTourScreen = document.getElementById('addTourScreen');

				//여행지 추가
				//map.addListener("click", addTour); //map 클릭 이벤트를 등록합니다.
				map.addListener("click", function (e) {
					if (addTourEnabled) {
						addTour(e.latLng);
					}
				});

				var addnewPlaces = [];

				// 작은 화면을 표시하는 함수
				function showSmallScreen(place) {
					// 작은 화면을 나타내는 div 요소 가져오기
					var smallScreen = document.getElementById("smallScreen");

					// 작은 화면 보이기
					smallScreen.style.display = "block";

					// 여행지 정보 표시
					document.getElementById('placeName').textContent = place.tourName;
					document.getElementById('placeDescription').textContent = place.tourContent;

					// "추가" 버튼 클릭 시 sidebar에 여행지 정보 newPlaces 배열에 추가
					document.getElementById('addToSidebarButton').onclick = function () {
						addnewPlaces.push(place);
						console.log("add", addnewPlaces, newPlaces);
						console.log("add", newPlaces.length - 1, addnewPlaces.length - 1);
						const transportButtons = createTransportButtons(newPlaces.length - 1, addnewPlaces.length - 1);
						let index10 = newPlaces.length + addnewPlaces.length - 1;
						console.log("index10", index10);
						addToSidebar(place.tourName, index10, transportButtons);
						smallScreen.style.display = "none";
					};
				}

				//sidebar
				function addToSidebar(placeName, index, transportButtons) {

					//sidebar에 여행지 정보 추가하는 함수
					var listItem = document.createElement('div');
					listItem.textContent = placeName;
					listItem.classList.add('sidebar-item'); // sidebar-item 클래스 추가
					sidebar.appendChild(listItem);

					// 추가된 여행지 삭제 버튼
					var deleteButton = document.createElement('button');
					deleteButton.textContent = '';
					deleteButton.classList.add('delete-button');
					listItem.appendChild(deleteButton);


					deleteButton.onclick = function () {
						console.log("itinerary", itinerary);

						const parent = transportButtons.parentNode;
						parent.removeChild(transportButtons);
						//listItem.removeChild(transportButtons);
						sidebar.removeChild(listItem);

						addnewPlaces.pop();
						// itinerary에서도 해당 인덱스의 항목을 삭제
						itinerary.splice(index, 1);

						// 인덱스 업데이트를 위해 삭제 후 나머지 항목들의 routeOrder 조정
						for (let i = index; i < itinerary.length; i++) {
							itinerary[i].routeOrder = i + 1;
						}

						console.log("removeitinerary", itinerary);
					};

					//return deleteButton;
				}

				let index1Used = false; // 상태 변수 추가

				// 이전 여행지와 현재 여행지 사이의 교통 정보 버튼 생성 함수
				function createTransportButtons(index1, index2) {
					console.log(index2);
					if (!index1Used && index1 > 0) {
						const transportDiv = document.createElement('div');
						transportDiv.classList.add('transport-buttons');

						// 자동차 버튼
						const carButton = document.createElement('button');
						carButton.textContent = '자동차';
						carButton.classList.add('onebutton');
						carButton.onclick = oneTransportButtonClick('자동차', index1, index2);

						// 도보 버튼
						const walkButton = document.createElement('button');
						walkButton.textContent = '도보';
						walkButton.classList.add('onebutton');
						walkButton.onclick = oneTransportButtonClick('도보', index1, index2);

						transportDiv.appendChild(carButton);
						transportDiv.appendChild(walkButton);

						const sidebar = document.getElementById('sidebar');
						const listItem = sidebar.lastChild;
						listItem.appendChild(transportDiv);
						index1Used = true; // index1 사용 후 상태 변경

						return transportDiv;
					} else {
						if (index2 > 0) {
							const transportDiv = document.createElement('div');
							transportDiv.classList.add('transport-buttons');

							// 자동차 버튼
							const carButton = document.createElement('button');
							carButton.textContent = '자동차';
							carButton.classList.add('onebutton');
							carButton.onclick = onTransportButtonClick('자동차', index2);

							// 도보 버튼
							const walkButton = document.createElement('button');
							walkButton.textContent = '도보';
							walkButton.classList.add('onebutton');
							walkButton.onclick = onTransportButtonClick('도보', index2);

							transportDiv.appendChild(carButton);
							transportDiv.appendChild(walkButton);

							const sidebar = document.getElementById('sidebar');
							const listItem = sidebar.lastChild;
							listItem.appendChild(transportDiv);
							return transportDiv;
						}
					}
				}

				// 도보 또는 자동차 버튼 클릭 시 호출되는 함수
				function oneTransportButtonClick(transportMode, index1, index2) {
					return function () {
						selectedTransportMode = transportMode;
						let transportInfo;
						if (transportMode === '자동차') {
							this.classList.add('blue-button');
							const buttons = this.parentNode.querySelectorAll('.onebutton');
							buttons.forEach(button => {
								if (button !== this) {
									button.classList.remove('green-button'); // 초기화

								}
							});
							transportInfo = getOneTransportInfoBetweenPlaces(newPlaces[newPlaces.length - 1], addnewPlaces[index2]);
						} else if (transportMode === '도보') {
							this.classList.add('green-button');
							const buttons = this.parentNode.querySelectorAll('.onebutton');
							buttons.forEach(button => {
								if (button !== this) {
									button.classList.remove('blue-button'); // 초기화

								}
							});
							transportInfo = getOneWalkInfoBetweenPlaces(newPlaces[newPlaces.length - 1], addnewPlaces[index2]);
						}

						// 결과를 담을 컨테이너를 생성합니다.
						const resultContainer = document.createElement('div');
						resultContainer.classList.add('result-container');
						resultContainer.textContent = "거리 : " + `${transportInfo.tDistance}` + "km, 소요 시간 : " + `${transportInfo.tTime}` + "분 "; // 예시로 tDistance와 tTime을 사용했습니다.

						// 버튼과 결과 컨테이너를 감싸고 있는 div 요소를 찾습니다.
						const containerDiv = this.parentNode;

						// 이전에 추가된 결과 컨테이너가 있다면 삭제합니다.
						const previousResultContainer = containerDiv.querySelector('.result-container');
						if (previousResultContainer) {
							containerDiv.removeChild(previousResultContainer);
						}

						// 자동차 또는 도보 버튼 옆에 결과 값을 추가합니다.
						containerDiv.insertBefore(resultContainer, this.nextSibling);

						// 클릭된 버튼의 배경색 변경
						//this.style.backgroundColor = 'lightblue';

						//this.classList.add('blue-button');

/*
						// 나머지 버튼의 배경색을 초기화
						const buttons = document.querySelectorAll('.onebutton');
						buttons.forEach(button => {
							if (button !== this) {
								button.classList.remove('green-button'); // 초기화

							}
						});*/

						addNewOldItineraryInfo(transportInfo, index1, index2);
						//updateNewItinerary(transportInfo);
					};
				}

				// 여행 정보를 itinerary 배열에 추가하는 함수
				function addNewOldItineraryInfo(transportInfo, index1, index2) {
					console.log("newPlaces ", newPlaces);
					console.log("addnewPlaces ", addnewPlaces);
					console.log("index1 ", index1);  //newPlaces
					console.log("index2 ", index2); //addnewPlaces
					//console.log("index ", newPlaces.length + index -1);
					let newIndex; // newIndex 변수를 블록 외부에서 선언

					if (index2 == 0 || index1 == 0) {
						newIndex = index1 + index2 + 1;
					} else {
						newIndex = index1 + index2;
					}


					console.log("newIndex ", newIndex);
					itinerary[newIndex] = {
						routeName: routeName,
						routeTraffic: selectedTransportMode,
						routeDistance: transportInfo.tDistance,
						routeTime: transportInfo.tTime,
						routeStartLocation: newPlaces[index1].routeEndLocation,
						routeEndLocation: addnewPlaces[index2].tourName,
						//routeUserId: user1, // 유저 아이디는 임시로 1로 설정됨
						routeStartLatitude: newPlaces[index1].routeEndLatitude,
						routeStartLongitude: newPlaces[index1].routeEndLongitude,
						routeEndLatitude: addnewPlaces[index2].lattitue,
						routeEndLongitude: addnewPlaces[index2].longtitue,
						routeOrder: newIndex+1
					};
					console.log("addNewOldItineraryInfo", itinerary);
				}
				/*
							// 여행 일정 업데이트 함수 수정
							function updateNewItinerary(transportInfo) {
								const currentIndex = addnewPlaces.length - 1;
								itinerary[currentIndex] = {
									//routeName: "",
									routeTraffic: selectedTransportMode,
									routeDistance: transportInfo.tDistance,
									routeTime: transportInfo.tTime,
									routeStartLocation: addnewPlaces[currentIndex - 1].tourName,
									routeEndLocation: addnewPlaces[currentIndex].tourName,
									//routeUserId: user1, // 유저 아이디는 임시로 1로 설정됨
									routeStartLatitude: addnewPlaces[currentIndex - 1].lattitue,
									routeStartLongitude: addnewPlaces[currentIndex - 1].longtitue,
									routeEndLatitude: addnewPlaces[currentIndex].lattitue,
									routeEndLongitude: addnewPlaces[currentIndex].longtitue,
									routeOrder: currentIndex
								};
							} */

				function getOneWalkInfoBetweenPlaces(place1, place2) {

					console.log(place1, place2);
					// 2. 시작, 도착 심볼찍기
					// 시작
					marker_s = new Tmapv2.Marker(
						{
							position: new Tmapv2.LatLng(place1.routeEndLongitude, place1.routeEndLatitude),
							icon: "/images/pin_r_m_s.png",
							iconSize: new Tmapv2.Size(24, 38),
							map: map
						});

					// 도착
					marker_e = new Tmapv2.Marker(
						{
							position: new Tmapv2.LatLng(place2.longtitue, place2.lattitue),
							icon: "/images/pin_r_m_e.png",
							iconSize: new Tmapv2.Size(24, 38),
							map: map
						});

					// 3. 경로탐색 API 사용요청
					var headers = {};
					headers["appKey"] = "6VYbMDkEY24DlbC0m8ymh1ESimWVROyI3sP7PqT1";

					$.ajax({
						method: "POST",
						headers: headers,
						url: "https://apis.openapi.sk.com/tmap/routes/pedestrian?version=1&format=json&callback=result",
						async: false,
						data: {
							"startX": place1.routeEndLongitude,
							"startY": place1.routeEndLatitude,
							"endX": place2.longtitue,
							"endY": place2.lattitue,
							"reqCoordType": "WGS84GEO",
							"resCoordType": "EPSG3857",
							"startName": "출발지",
							"endName": "도착지"
						},
						success: function (response) {
							var resultData = response.features;

							transportData.tDistance =
								((resultData[0].properties.totalDistance) / 1000)
									.toFixed(1);

							transportData.tTime =
								((resultData[0].properties.totalTime) / 60)
									.toFixed(0);


							//기존 그려진 라인 & 마커가 있다면 초기화
							if (resultdrawArr.length > 0) {
								for (var i in resultdrawArr) {
									resultdrawArr[i]
										.setMap(null);
								}
								resultdrawArr = [];
							}

							drawInfoArr = [];

							for (var i in resultData) { //for문 [S]
								var geometry = resultData[i].geometry;
								var properties = resultData[i].properties;
								var polyline_;


								if (geometry.type == "LineString") {
									for (var j in geometry.coordinates) {
										// 경로들의 결과값(구간)들을 포인트 객체로 변환 
										var latlng = new Tmapv2.Point(
											geometry.coordinates[j][0],
											geometry.coordinates[j][1]);
										// 포인트 객체를 받아 좌표값으로 변환
										var convertPoint = new Tmapv2.Projection.convertEPSG3857ToWGS84GEO(
											latlng);
										// 포인트객체의 정보로 좌표값 변환 객체로 저장
										var convertChange = new Tmapv2.LatLng(
											convertPoint._lat,
											convertPoint._lng);
										// 배열에 담기
										drawInfoArr.push(convertChange);
									}
								} else {
									var markerImg = "";
									var pType = "";
									var size;

									if (properties.pointType == "S") { //출발지 마커
										markerImg = "/images/pin_r_m_s.png";
										pType = "S";
										size = new Tmapv2.Size(24, 38);
									} else if (properties.pointType == "E") { //도착지 마커
										markerImg = "/images/pin_r_m_e.png";
										pType = "E";
										size = new Tmapv2.Size(24, 38);
									} else { //각 포인트 마커
										//markerImg = "http://topopen.tmap.co.kr/imgs/point.png";
										pType = "P";
										size = new Tmapv2.Size(0, 0);
									}

									// 경로들의 결과값들을 포인트 객체로 변환 
									var latlon = new Tmapv2.Point(
										geometry.coordinates[0],
										geometry.coordinates[1]);

									// 포인트 객체를 받아 좌표값으로 다시 변환
									var convertPoint = new Tmapv2.Projection.convertEPSG3857ToWGS84GEO(
										latlon);

									var routeInfoObj = {
										markerImage: markerImg,
										lng: convertPoint._lng,
										lat: convertPoint._lat,
										pointType: pType
									};

									// Marker 추가
									marker_p = new Tmapv2.Marker(
										{
											position: new Tmapv2.LatLng(
												routeInfoObj.lat,
												routeInfoObj.lng),
											icon: routeInfoObj.markerImage,
											iconSize: size,
											map: map
										});
								}
							}//for문 [E]
							drawLine(drawInfoArr);
						},
						error: function (request, status, error) {
							console.log("code:" + request.status + "\n"
								+ "message:" + request.responseText + "\n"
								+ "error:" + error);
						}
					});

					return transportData;
				}


				function getOneTransportInfoBetweenPlaces(place1, place2) {
					// 2. 시작, 도착 심볼찍기
					// 시작
					marker_s = new Tmapv2.Marker({
						position: new Tmapv2.LatLng(place1.routeEndLongitude,
							place1.routeEndLatitude),
						icon: "/images/pin_r_m_s.png",
						iconSize: new Tmapv2.Size(24, 38),
						map: map
					});

					//도착
					marker_e = new Tmapv2.Marker({
						position: new Tmapv2.LatLng(place2.longitude,
							place2.latitude),
						icon: "/images/pin_r_m_e.png",
						iconSize: new Tmapv2.Size(24, 38),
						map: map
					});
					console.log("markere : {}", marker_e);

					//기존 맵에 있던 정보들 초기화
					resettingMap();

					var searchOption = $("#selectLevel").val();

					var trafficInfochk = $("#year").val();
					var headers = {};
					headers["appKey"] = "6VYbMDkEY24DlbC0m8ymh1ESimWVROyI3sP7PqT1";

					//JSON TYPE EDIT [S]
					$.ajax({
						type: "POST",
						headers: headers,
						url: "https://apis.openapi.sk.com/tmap/routes?version=1&format=json&callback=result&appKey=6VYbMDkEY24DlbC0m8ymh1ESimWVROyI3sP7PqT1",
						async: false,
						data: {
							"startX": place1.routeEndLongitude,
							"startY": place1.routeEndLatitude,
							"endX": place2.longtitue,
							"endY": place2.lattitue,
							"reqCoordType": "WGS84GEO",
							"resCoordType": "EPSG3857",
							"searchOption": searchOption,
							"trafficInfo": trafficInfochk
						},
						success: function (response) {

							var resultData = response.features;

							transportData.tDistance =
								((resultData[0].properties.totalDistance) / 1000)
									.toFixed(1);

							transportData.tTime =
								((resultData[0].properties.totalTime) / 60)
									.toFixed(0);

							for (var i in resultData) { //for문 [S]
								var geometry = resultData[i].geometry;
								var properties = resultData[i].properties;

								if (geometry.type == "LineString") {
									for (var j in geometry.coordinates) {
										// 경로들의 결과값들을 포인트 객체로 변환 
										var latlng = new Tmapv2.Point(
											geometry.coordinates[j][0],
											geometry.coordinates[j][1]);
										// 포인트 객체를 받아 좌표값으로 변환
										var convertPoint = new Tmapv2.Projection.convertEPSG3857ToWGS84GEO(
											latlng);
										// 포인트객체의 정보로 좌표값 변환 객체로 저장
										var convertChange = new Tmapv2.LatLng(
											convertPoint._lat,
											convertPoint._lng);
										// 배열에 담기
										drawInfoArr
											.push(convertChange);
									}
									drawLine(drawInfoArr,
										"0");
								} else {

									var markerImg = "";
									var pType = "";

									if (properties.pointType == "S") { //출발지 마커
										markerImg = "/images/pin_r_m_s.png";
										pType = "S";
									} else if (properties.pointType == "E") { //도착지 마커
										markerImg = "/images/pin_r_m_e.png";
										pType = "E";
									} else { //각 포인트 마커
										//markerImg = "http://topopen.tmap.co.kr/imgs/point.png";
										pType = "P"
									}

									// 경로들의 결과값들을 포인트 객체로 변환 
									var latlon = new Tmapv2.Point(
										geometry.coordinates[0],
										geometry.coordinates[1]);
									// 포인트 객체를 받아 좌표값으로 다시 변환
									var convertPoint = new Tmapv2.Projection.convertEPSG3857ToWGS84GEO(
										latlon);

									var routeInfoObj = {
										markerImage: markerImg,
										lng: convertPoint._lng,
										lat: convertPoint._lat,
										pointType: pType
									};

									// Marker 추가
									addMarkers(routeInfoObj);
								}
							}//for문 [E]

						},
						error: function (request, status, error) {
							console.log("code:"
								+ request.status + "\n"
								+ "message:"
								+ request.responseText
								+ "\n" + "error:" + error);
						}
					});
					return transportData;

				}//end getoneTransportInfoBetweenPlaces



				// 도보 또는 자동차 버튼 클릭 시 호출되는 함수
				function onTransportButtonClick(transportMode, index) {
					console.log(addnewPlaces);
					return function () {
						selectedTransportMode = transportMode;
						let transportInfo;
						if (transportMode === '자동차') {
							this.classList.add('blue-button');
							const buttons = this.parentNode.querySelectorAll('.onebutton');
							buttons.forEach(button => {
								if (button !== this) {
									button.classList.remove('green-button'); // 초기화

								}
							});
							transportInfo = getTwoTransportInfoBetweenPlaces(addnewPlaces[index - 1], addnewPlaces[index]);
						} else if (transportMode === '도보') {
							this.classList.add('green-button');
							const buttons = this.parentNode.querySelectorAll('.onebutton');
							buttons.forEach(button => {
								if (button !== this) {
									button.classList.remove('blue-button'); // 초기화

								}
							});
							transportInfo = getTwoWalkInfoBetweenPlaces(addnewPlaces[index - 1], addnewPlaces[index]);
						}

						// 결과를 담을 컨테이너를 생성합니다.
						const resultContainer = document.createElement('div');
						resultContainer.classList.add('result-container');
						resultContainer.textContent = "거리 : " + `${transportInfo.tDistance}` + "km, 소요 시간 : " + `${transportInfo.tTime}` + "분 "; // 예시로 tDistance와 tTime을 사용했습니다.

						// 버튼과 결과 컨테이너를 감싸고 있는 div 요소를 찾습니다.
						const containerDiv = this.parentNode;

						// 이전에 추가된 결과 컨테이너가 있다면 삭제합니다.
						const previousResultContainer = containerDiv.querySelector('.result-container');
						if (previousResultContainer) {
							containerDiv.removeChild(previousResultContainer);
						}

						// 자동차 또는 도보 버튼 옆에 결과 값을 추가합니다.
						containerDiv.insertBefore(resultContainer, this.nextSibling);

						// 클릭된 버튼의 배경색 변경
						//this.style.backgroundColor = 'lightblue';
/*
						// 나머지 버튼의 배경색을 초기화
						const buttons = document.querySelectorAll('.get-transport-info');
						buttons.forEach(button => {
							if (button !== this) {
								button.style.backgroundColor = ''; // 초기화
							}
						});*/

						addNewItineraryInfo(transportInfo, index);
						//updateNewItinerary(transportInfo);
					};
				}



				// 여행 정보를 itinerary 배열에 추가하는 함수
				function addNewItineraryInfo(transportInfo, index) {
					console.log("two ", addnewPlaces);
					console.log("index ", index);
					console.log("index ", newPlaces.length + index - 1);
					let newIndex = newPlaces.length + index;
					itinerary[newIndex] = {
						routeName: routeName,
						routeTraffic: selectedTransportMode,
						routeDistance: transportInfo.tDistance,
						routeTime: transportInfo.tTime,
						routeStartLocation: addnewPlaces[index - 1].tourName,
						routeEndLocation: addnewPlaces[index].tourName,
						//routeUserId: user1, // 유저 아이디는 임시로 1로 설정됨
						routeStartLatitude: addnewPlaces[index - 1].lattitue,
						routeStartLongitude: addnewPlaces[index - 1].longtitue,
						routeEndLatitude: addnewPlaces[index].lattitue,
						routeEndLongitude: addnewPlaces[index].longtitue,
						routeOrder: newIndex
					};
					console.log("two itinerary", itinerary);
				}
				/*
							// 여행 일정 업데이트 함수 수정
							function updateNewItinerary(transportInfo) {
								const currentIndex = addnewPlaces.length - 1;
								itinerary[currentIndex] = {
									//routeName: "",
									routeTraffic: selectedTransportMode,
									routeDistance: transportInfo.tDistance,
									routeTime: transportInfo.tTime,
									routeStartLocation: addnewPlaces[currentIndex - 1].tourName,
									routeEndLocation: addnewPlaces[currentIndex].tourName,
									//routeUserId: user1, // 유저 아이디는 임시로 1로 설정됨
									routeStartLatitude: addnewPlaces[currentIndex - 1].lattitue,
									routeStartLongitude: addnewPlaces[currentIndex - 1].longtitue,
									routeEndLatitude: addnewPlaces[currentIndex].lattitue,
									routeEndLongitude: addnewPlaces[currentIndex].longtitue,
									routeOrder: currentIndex
								};
							} */

/*
				// 여행 일정 저장 함수
				function saveItinerary() {

					// 이전 일정을 삭제한 후 새로운 일정을 저장
					deleteItinerary();

					console.log("saveItinerary", itinerary);


					// 각 일정을 순회하면서 서버로 데이터 전송
					itinerary.forEach(function (item) {
						//item.routeName = routeNameValue; // 변수명 변경
						console.log("routeUserId", routeUserId);

						item.routeUserId = routeUserId;
						$.ajax({
							method: "POST",
							url: "/route/save",
							data: JSON.stringify(item),
							contentType: "application/json; charset=utf-8",
							dataType: "json",
							success: function (response) {
								console.log(response.message);
								console.log("여행 일정이 저장되었습니다.html");
								window.location.href = "/route/list";
							},
							error: function (request, status, error) {
								console.log("여행 일정 저장에 실패했습니다html");
								console.log(request); // 요청 정보 확인
								console.log(status); // 상태 코드 확인
								console.log(error); // 오류 메시지 확인
							}
						});
					});
				} */

				async function saveItinerary() {
					try {
						await deleteItinerary(); // 일정 삭제가 완료될 때까지 기다림

						// 이전 일정을 삭제한 후 새로운 일정을 저장
						console.log("saveItinerary", itinerary);

						// 각 일정을 순회하면서 서버로 데이터 전송
						for (const item of itinerary) {
							// item.routeName = routeNameValue; // 변수명 변경
							console.log("routeUserId", routeUserId);

							item.routeUserId = routeUserId;
							const response = await $.ajax({
								method: "POST",
								url: "/route/save",
								data: JSON.stringify(item),
								contentType: "application/json; charset=utf-8",
								dataType: "json"
							});
							console.log(response.message);
							console.log("여행 일정이 저장되었습니다.html");
							window.location.href = "/routeList";
						}
					} catch (error) {
						console.error("오류 발생:", error);
					}
				}

				async function deleteItinerary() {
					return new Promise(function (resolve, reject) {
						$.ajax({
							method: "DELETE",
							url: "/route/deleteAll/" + routeName,
							//data : routeName,
							success: function (response) {
								console.log(response.message);
								console.log("성공?");

								// AJAX 요청이 성공한 후에 resolve 호출
								resolve();
							},
							error: function (request, status, error) {
								console.log("여행 일정 삭제에 실패했습니다:");
								console.log(request);
								console.log(status);
								console.log(error);
								// AJAX 요청이 실패한 경우 reject 호출
								reject(error);
							}
						});
					});
				}

				/*
								// 여행 일정 삭제 함수
								function deleteItinerary() {
									$.ajax({
										method: "DELETE",
										url: "/route/deleteAll/" + routeName,
										//data : routeName,
										success: function (response) {
											console.log(response.message);
											console.log("성공?");
				
											// 일정이 성공적으로 삭제되면 새로운 일정을 저장
											//saveItinerary();
										},
										error: function (request, status, error) {
											console.log("여행 일정 삭제에 실패했습니다:");
											console.log(request);
											console.log(status);
											console.log(error);
										}
									});
								} */

				// 여행 일정 저장 버튼 클릭 이벤트 핸들러
				document.getElementById('saveItineraryButton').onclick = saveItinerary;

				//--------------------------------------------------------




				function getTwoWalkInfoBetweenPlaces(place1, place2) {

					console.log(place1, place2);
					// 2. 시작, 도착 심볼찍기
					// 시작
					marker_s = new Tmapv2.Marker(
						{
							position: new Tmapv2.LatLng(37.564991, 126.983937),
							icon: "/images/pin_r_m_s.png",
							iconSize: new Tmapv2.Size(24, 38),
							map: map
						});

					// 도착
					marker_e = new Tmapv2.Marker(
						{
							position: new Tmapv2.LatLng(37.566158, 126.988940),
							icon: "/images/pin_r_m_e.png",
							iconSize: new Tmapv2.Size(24, 38),
							map: map
						});

					// 3. 경로탐색 API 사용요청
					var headers = {};
					headers["appKey"] = "6VYbMDkEY24DlbC0m8ymh1ESimWVROyI3sP7PqT1";

					$.ajax({
						method: "POST",
						headers: headers,
						url: "https://apis.openapi.sk.com/tmap/routes/pedestrian?version=1&format=json&callback=result",
						async: false,
						data: {
							"startX": place1.longtitue,
							"startY": place1.lattitue,
							"endX": place2.longtitue,
							"endY": place2.lattitue,
							"reqCoordType": "WGS84GEO",
							"resCoordType": "EPSG3857",
							"startName": "출발지",
							"endName": "도착지"
						},
						success: function (response) {
							var resultData = response.features;

							transportData.tDistance =
								((resultData[0].properties.totalDistance) / 1000)
									.toFixed(1);

							transportData.tTime =
								((resultData[0].properties.totalTime) / 60)
									.toFixed(0);


							//기존 그려진 라인 & 마커가 있다면 초기화
							if (resultdrawArr.length > 0) {
								for (var i in resultdrawArr) {
									resultdrawArr[i]
										.setMap(null);
								}
								resultdrawArr = [];
							}

							drawInfoArr = [];

							for (var i in resultData) { //for문 [S]
								var geometry = resultData[i].geometry;
								var properties = resultData[i].properties;
								var polyline_;


								if (geometry.type == "LineString") {
									for (var j in geometry.coordinates) {
										// 경로들의 결과값(구간)들을 포인트 객체로 변환 
										var latlng = new Tmapv2.Point(
											geometry.coordinates[j][0],
											geometry.coordinates[j][1]);
										// 포인트 객체를 받아 좌표값으로 변환
										var convertPoint = new Tmapv2.Projection.convertEPSG3857ToWGS84GEO(
											latlng);
										// 포인트객체의 정보로 좌표값 변환 객체로 저장
										var convertChange = new Tmapv2.LatLng(
											convertPoint._lat,
											convertPoint._lng);
										// 배열에 담기
										drawInfoArr.push(convertChange);
									}
								} else {
									var markerImg = "";
									var pType = "";
									var size;

									if (properties.pointType == "S") { //출발지 마커
										markerImg = "/images/pin_r_m_s.png";
										pType = "S";
										size = new Tmapv2.Size(24, 38);
									} else if (properties.pointType == "E") { //도착지 마커
										markerImg = "/images/pin_r_m_e.png";
										pType = "E";
										size = new Tmapv2.Size(24, 38);
									} else { //각 포인트 마커
										//markerImg = "http://topopen.tmap.co.kr/imgs/point.png";
										pType = "P";
										size = new Tmapv2.Size(0, 0);
									}

									// 경로들의 결과값들을 포인트 객체로 변환 
									var latlon = new Tmapv2.Point(
										geometry.coordinates[0],
										geometry.coordinates[1]);

									// 포인트 객체를 받아 좌표값으로 다시 변환
									var convertPoint = new Tmapv2.Projection.convertEPSG3857ToWGS84GEO(
										latlon);

									var routeInfoObj = {
										markerImage: markerImg,
										lng: convertPoint._lng,
										lat: convertPoint._lat,
										pointType: pType
									};

									// Marker 추가
									marker_p = new Tmapv2.Marker(
										{
											position: new Tmapv2.LatLng(
												routeInfoObj.lat,
												routeInfoObj.lng),
											icon: routeInfoObj.markerImage,
											iconSize: size,
											map: map
										});
								}
							}//for문 [E]
							drawLine(drawInfoArr);
						},
						error: function (request, status, error) {
							console.log("code:" + request.status + "\n"
								+ "message:" + request.responseText + "\n"
								+ "error:" + error);
						}
					});

					return transportData;
				}


				function getTwoTransportInfoBetweenPlaces(place1, place2) {
					// 2. 시작, 도착 심볼찍기
					// 시작
					marker_s = new Tmapv2.Marker({
						position: new Tmapv2.LatLng(place1.latitude,
							place1.longitude),
						icon: "/images/pin_r_m_s.png",
						iconSize: new Tmapv2.Size(24, 38),
						map: map
					});

					//도착
					marker_e = new Tmapv2.Marker({
						position: new Tmapv2.LatLng(place2.latitude,
							place2.longitude),
						icon: "/images/pin_r_m_e.png",
						iconSize: new Tmapv2.Size(24, 38),
						map: map
					});
					console.log("markere : {}", marker_e);

					//기존 맵에 있던 정보들 초기화
					resettingMap();

					var searchOption = $("#selectLevel").val();

					var trafficInfochk = $("#year").val();
					var headers = {};
					headers["appKey"] = "6VYbMDkEY24DlbC0m8ymh1ESimWVROyI3sP7PqT1";

					//JSON TYPE EDIT [S]
					$.ajax({
						type: "POST",
						headers: headers,
						url: "https://apis.openapi.sk.com/tmap/routes?version=1&format=json&callback=result&appKey=6VYbMDkEY24DlbC0m8ymh1ESimWVROyI3sP7PqT1",
						async: false,
						data: {
							"startX": place1.longtitue,
							"startY": place1.lattitue,
							"endX": place2.longtitue,
							"endY": place2.lattitue,
							"reqCoordType": "WGS84GEO",
							"resCoordType": "EPSG3857",
							"searchOption": searchOption,
							"trafficInfo": trafficInfochk
						},
						success: function (response) {

							var resultData = response.features;

							transportData.tDistance =
								((resultData[0].properties.totalDistance) / 1000)
									.toFixed(1);

							transportData.tTime =
								((resultData[0].properties.totalTime) / 60)
									.toFixed(0);

							for (var i in resultData) { //for문 [S]
								var geometry = resultData[i].geometry;
								var properties = resultData[i].properties;

								if (geometry.type == "LineString") {
									for (var j in geometry.coordinates) {
										// 경로들의 결과값들을 포인트 객체로 변환 
										var latlng = new Tmapv2.Point(
											geometry.coordinates[j][0],
											geometry.coordinates[j][1]);
										// 포인트 객체를 받아 좌표값으로 변환
										var convertPoint = new Tmapv2.Projection.convertEPSG3857ToWGS84GEO(
											latlng);
										// 포인트객체의 정보로 좌표값 변환 객체로 저장
										var convertChange = new Tmapv2.LatLng(
											convertPoint._lat,
											convertPoint._lng);
										// 배열에 담기
										drawInfoArr
											.push(convertChange);
									}
									drawLine(drawInfoArr,
										"0");
								} else {

									var markerImg = "";
									var pType = "";

									if (properties.pointType == "S") { //출발지 마커
										markerImg = "/images/pin_r_m_s.png";
										pType = "S";
									} else if (properties.pointType == "E") { //도착지 마커
										markerImg = "/images/pin_r_m_e.png";
										pType = "E";
									} else { //각 포인트 마커
										//markerImg = "http://topopen.tmap.co.kr/imgs/point.png";
										pType = "P"
									}

									// 경로들의 결과값들을 포인트 객체로 변환 
									var latlon = new Tmapv2.Point(
										geometry.coordinates[0],
										geometry.coordinates[1]);
									// 포인트 객체를 받아 좌표값으로 다시 변환
									var convertPoint = new Tmapv2.Projection.convertEPSG3857ToWGS84GEO(
										latlon);

									var routeInfoObj = {
										markerImage: markerImg,
										lng: convertPoint._lng,
										lat: convertPoint._lat,
										pointType: pType
									};

									// Marker 추가
									addMarkers(routeInfoObj);
								}
							}//for문 [E]

						},
						error: function (request, status, error) {
							console.log("code:"
								+ request.status + "\n"
								+ "message:"
								+ request.responseText
								+ "\n" + "error:" + error);
						}
					});
					return transportData;

				}//end getTransportInfoBetweenPlaces














				// displayRoutes 함수: 루트 데이터를 받아와서 화면에 버튼을 생성하는 함수
				function displayRoutes(routes) {

					const sidebar = document.getElementById('sidebar');
					//sidebar.innerHTML = ''; // 이전에 생성된 내용 초기화


					console.log(routes);

					// 루트 이름 설정
					const routeNameDiv = document.getElementById('routeName');
					routeNameDiv.innerHTML = '이름 : ' + routes[0].routeName;
					routeName = routes[0].routeName;

					var totalDistance = 0;
					routes.forEach(route => {
						totalDistance += route.routeDistance;
					});

					// totalDistance를 표시할 새로운 div 요소 생성
					const totalDistanceDiv = document.createElement('div');
					totalDistanceDiv.textContent = `총 거리: ${totalDistance}`;
					sidebar.appendChild(totalDistanceDiv); // sidebar에 추가


					// 루트를 routeOrder의 오름차순으로 정렬
					routes.sort((a, b) => a.routeOrder - b.routeOrder);

					// 각 루트마다 버튼 생성
					for (let i = 0; i < routes.length; i++) {
						newPlaces.push(routes[i]);
						console.log("new {}", newPlaces);

						//let index = i;
						const route = routes[i];
						console.log("route", route);
						const transportButtonsDiv = document.createElement('div');


						// 처음 루트에 대해서만 출발지 정보를 표시
						if (i === 0) {
							const startLocationDiv = document.createElement('div');
							startLocationDiv.textContent = ` ${route.routeStartLocation}`;
							transportButtonsDiv.appendChild(startLocationDiv);
						}

						// 자동차 버튼 생성
						const carButton = createButton('자동차', function () {
							selectedTransportMode = '자동차';
							carButton.classList.add('blue-button');
							walkButton.classList.remove('green-button');

							const transportInfo = getTransportInfoBetweenPlaces(route);
							updateItinerary(transportInfo);
						});
						transportButtonsDiv.appendChild(carButton);

						// 도보 버튼 생성
						const walkButton = createButton('도보', function () {
							selectedTransportMode = '도보';
							carButton.classList.remove('blue-button');
							walkButton.classList.add('green-button');
							const transportInfo = getWalkInfoBetweenPlaces(route);
							updateItinerary(transportInfo);
						});
						transportButtonsDiv.appendChild(walkButton);


						// routeTraffic가 "자동차"일 때 자동차 버튼의 색상을 파란색으로 지정
						if (route.routeTraffic === "자동차") {
							carButton.classList.add('blue-button'); // 예시로 'blue-button' 클래스를 추가
							//console.log("파란 자동");
							onTransportButtonDisplay(route.routeTraffic, route);
						} else if (route.routeTraffic === "도보") {
							walkButton.classList.add('green-button'); // 예시로 'green-button' 클래스를 추가
							onTransportButtonDisplay(route.routeTraffic, route);
						}

						// 삭제 버튼 생성
						const deleteButton = createDeleteButton(route, transportButtonsDiv, i); // 삭제 버튼 생성 함수 호출
						transportButtonsDiv.appendChild(deleteButton);

						// 도착지 정보를 생성합니다.
						const endLocationDiv = document.createElement('div');
						endLocationDiv.textContent = `${route.routeEndLocation}`;
						transportButtonsDiv.appendChild(endLocationDiv);

						// 생성한 버튼을 sidebar에 추가
						sidebar.appendChild(transportButtonsDiv);
					}


				}

				// createButton 함수: 주어진 텍스트와 클릭 이벤트 핸들러로 버튼을 생성하는 함수
				function createButton(text, clickHandler) {
					const button = document.createElement('button');
					button.textContent = text;
					button.onclick = clickHandler;
					return button;
				}

				// 도보 또는 자동차 버튼 생성 시 호출되는 함수
				function onTransportButtonDisplay(transportMode, route) {
					selectedTransportMode = transportMode;
					let transportInfo;
					if (transportMode === '자동차') {
						console.log(transportMode);
						transportInfo = getTransportInfoBetweenPlaces(route);
					} else if (transportMode === '도보') {
						transportInfo = getWalkInfoBetweenPlaces(route);
					}

					console.log("route.routeOrder", route.routeOrder);

					addItineraryInfo(transportMode, route.routeOrder);
				}

				// 삭제 버튼 생성 함수
				function createDeleteButton(route, listItem, index) {

					const deleteButton = document.createElement('button');
					deleteButton.textContent = '';
					deleteButton.classList.add('delete-button');
					deleteButton.onclick = function () {

						sidebar.removeChild(listItem);
						newPlaces.pop();
						//newPlaces.splice(listItem, 1);
						//console.log("new remove{}", newPlaces);

						// itinerary에서도 해당 인덱스의 항목을 삭제
						itinerary.splice(index, 1);

						// 인덱스 업데이트를 위해 삭제 후 나머지 항목들의 routeOrder 조정
						for (let i = index; i < itinerary.length; i++) {
							itinerary[i].routeOrder = i + 1;
						}

						console.log("removeitinerary", itinerary);
					};

					return deleteButton;
				}

				// 여행 일정 업데이트 함수 수정
				function updateItinerary(transportInfo) {
					const currentIndex = newPlaces.length - 1;
					itinerary[currentIndex] = {
						routeName: "",
						routeTraffic: selectedTransportMode,
						routeDistance: transportInfo.tDistance,
						routeTime: transportInfo.tTime,
						routeStartLocation: newPlaces[currentIndex - 1].tourName,
						routeEndLocation: newPlaces[currentIndex].tourName,
						//routeUserId: user1, // 유저 아이디는 임시로 1로 설정됨
						routeStartLatitude: newPlaces[currentIndex - 1].lattitue,
						routeStartLongitude: newPlaces[currentIndex - 1].longtitue,
						routeEndLatitude: newPlaces[currentIndex].lattitue,
						routeEndLongitude: newPlaces[currentIndex].longtitue,
						routeOrder: currentIndex
					};
					console.log("update", itinerary);
				}

				// 여행 정보를 itinerary 배열에 추가하는 함수
				function addItineraryInfo(transportMode, index) {
					itinerary[index - 1] = {
						routeName: newPlaces[index - 1].routeName,
						routeTraffic: transportMode,
						routeDistance: newPlaces[index - 1].routeDistance,
						routeTime: newPlaces[index - 1].routeTime,
						routeStartLocation: newPlaces[index - 1].routeStartLocation,
						routeEndLocation: newPlaces[index - 1].routeEndLocation,
						//routeUserId: user1, // 유저 아이디는 임시로 1로 설정됨
						routeStartLatitude: newPlaces[index - 1].routeStartLatitude,
						routeStartLongitude: newPlaces[index - 1].routeStartLongitude,
						routeEndLatitude: newPlaces[index - 1].routeEndLatitude,
						routeEndLongitude: newPlaces[index - 1].routeEndLongitude,
						routeOrder: index
					};

					console.log("additinerary", itinerary);
				}


				function getWalkInfoBetweenPlaces(route) {
					console.log("place1walk", route);
					// 2. 시작, 도착 심볼찍기
					// 시작
					marker_s = new Tmapv2.Marker(
						{
							position: new Tmapv2.LatLng(route.routeStartLatitude, route.routeStartLongitude),
							icon: "/images/pin_r_m_s.png",
							iconSize: new Tmapv2.Size(24, 38),
							map: map
						});

					// 도착
					marker_e = new Tmapv2.Marker(
						{
							position: new Tmapv2.LatLng(route.routeEndLatitude, route.routeEndLongitude),
							icon: "/images/pin_r_m_e.png",
							iconSize: new Tmapv2.Size(24, 38),
							map: map
						});

					// 3. 경로탐색 API 사용요청
					var headers = {};
					headers["appKey"] = "6VYbMDkEY24DlbC0m8ymh1ESimWVROyI3sP7PqT1";

					$.ajax({
						method: "POST",
						headers: headers,
						url: "https://apis.openapi.sk.com/tmap/routes/pedestrian?version=1&format=json&callback=result",
						async: false,
						data: {
							"startX": route.routeStartLongitude,
							"startY": route.routeStartLatitude,
							"endX": route.routeEndLongitude,
							"endY": route.routeEndLatitude,
							"reqCoordType": "WGS84GEO",
							"resCoordType": "EPSG3857",
							"startName": "출발지",
							"endName": "도착지"
						},
						success: function (response) {
							var resultData = response.features;

							transportData.tDistance =
								((resultData[0].properties.totalDistance) / 1000)
									.toFixed(1);

							transportData.tTime =
								((resultData[0].properties.totalTime) / 60)
									.toFixed(0);


							drawInfoArr = [];

							for (var i in resultData) { //for문 [S]
								var geometry = resultData[i].geometry;
								var properties = resultData[i].properties;
								var polyline_;


								if (geometry.type == "LineString") {
									for (var j in geometry.coordinates) {
										// 경로들의 결과값(구간)들을 포인트 객체로 변환 
										var latlng = new Tmapv2.Point(
											geometry.coordinates[j][0],
											geometry.coordinates[j][1]);
										// 포인트 객체를 받아 좌표값으로 변환
										var convertPoint = new Tmapv2.Projection.convertEPSG3857ToWGS84GEO(
											latlng);
										// 포인트객체의 정보로 좌표값 변환 객체로 저장
										var convertChange = new Tmapv2.LatLng(
											convertPoint._lat,
											convertPoint._lng);
										// 배열에 담기
										drawInfoArr.push(convertChange);
									}
								} else {
									var markerImg = "";
									var pType = "";
									var size;

									if (properties.pointType == "S") { //출발지 마커
										markerImg = "/images/pin_r_m_s.png";
										pType = "S";
										size = new Tmapv2.Size(24, 38);
									} else if (properties.pointType == "E") { //도착지 마커
										markerImg = "/images/pin_r_m_e.png";
										pType = "E";
										size = new Tmapv2.Size(24, 38);
									} else { //각 포인트 마커
										//markerImg = "http://topopen.tmap.co.kr/imgs/point.png";
										pType = "P";
										size = new Tmapv2.Size(0, 0);
									}

									// 경로들의 결과값들을 포인트 객체로 변환 
									var latlon = new Tmapv2.Point(
										geometry.coordinates[0],
										geometry.coordinates[1]);

									// 포인트 객체를 받아 좌표값으로 다시 변환
									var convertPoint = new Tmapv2.Projection.convertEPSG3857ToWGS84GEO(
										latlon);

									var routeInfoObj = {
										markerImage: markerImg,
										lng: convertPoint._lng,
										lat: convertPoint._lat,
										pointType: pType
									};

									// Marker 추가
									marker_p = new Tmapv2.Marker(
										{
											position: new Tmapv2.LatLng(
												routeInfoObj.lat,
												routeInfoObj.lng),
											icon: routeInfoObj.markerImage,
											iconSize: size,
											map: map
										});
								}
							}//for문 [E]
							drawLine(drawInfoArr);
						},
						error: function (request, status, error) {
							console.log("code:" + request.status + "\n"
								+ "message:" + request.responseText + "\n"
								+ "error:" + error);
						}
					});

					return transportData;
				}



				function getTransportInfoBetweenPlaces(route) {
					console.log("place1 자동차 ", route);
					// 2. 시작, 도착 심볼찍기
					// 시작
					marker_s = new Tmapv2.Marker({
						position: new Tmapv2.LatLng(route.routeStartLatitude, route.routeStartLongitude),
						icon: "/images/pin_r_m_s.png",
						iconSize: new Tmapv2.Size(24, 38),
						map: map
					});

					// 도착
					marker_e = new Tmapv2.Marker({
						position: new Tmapv2.LatLng(route.routeEndLatitude, route.routeEndLongitude),
						icon: "/images/pin_r_m_e.png",
						iconSize: new Tmapv2.Size(24, 38),
						map: map
					});
					console.log("markere : {}", marker_e);

					//기존 맵에 있던 정보들 초기화
					//resettingMap();

					var searchOption = $("#selectLevel").val();

					var trafficInfochk = $("#year").val();
					var headers = {};
					headers["appKey"] = "6VYbMDkEY24DlbC0m8ymh1ESimWVROyI3sP7PqT1";

					//JSON TYPE EDIT [S]
					$.ajax({
						type: "POST",
						headers: headers,
						url: "https://apis.openapi.sk.com/tmap/routes?version=1&format=json&callback=result&appKey=6VYbMDkEY24DlbC0m8ymh1ESimWVROyI3sP7PqT1",
						async: false,
						data: {
							"startX": route.routeStartLongitude,
							"startY": route.routeStartLatitude,
							"endX": route.routeEndLongitude,
							"endY": route.routeEndLatitude,
							"reqCoordType": "WGS84GEO",
							"resCoordType": "EPSG3857",
							"searchOption": searchOption,
							"trafficInfo": trafficInfochk
						},
						success: function (response) {

							var resultData = response.features;

							transportData.tDistance =
								((resultData[0].properties.totalDistance) / 1000)
									.toFixed(1);

							transportData.tTime =
								((resultData[0].properties.totalTime) / 60)
									.toFixed(0);

							for (var i in resultData) { //for문 [S]
								var geometry = resultData[i].geometry;
								var properties = resultData[i].properties;

								if (geometry.type == "LineString") {
									for (var j in geometry.coordinates) {
										// 경로들의 결과값들을 포인트 객체로 변환 
										var latlng = new Tmapv2.Point(
											geometry.coordinates[j][0],
											geometry.coordinates[j][1]);
										// 포인트 객체를 받아 좌표값으로 변환
										var convertPoint = new Tmapv2.Projection.convertEPSG3857ToWGS84GEO(
											latlng);
										// 포인트객체의 정보로 좌표값 변환 객체로 저장
										var convertChange = new Tmapv2.LatLng(
											convertPoint._lat,
											convertPoint._lng);
										// 배열에 담기
										drawInfoArr
											.push(convertChange);
									}
									drawLine(drawInfoArr,
										"0");
								} else {

									var markerImg = "";
									var pType = "";

									if (properties.pointType == "S") { //출발지 마커
										markerImg = "/images/pin_r_m_s.png";
										pType = "S";
									} else if (properties.pointType == "E") { //도착지 마커
										markerImg = "/images/pin_r_m_e.png";
										pType = "E";
									} else { //각 포인트 마커
										//markerImg = "http://topopen.tmap.co.kr/imgs/point.png";
										pType = "P"
									}

									// 경로들의 결과값들을 포인트 객체로 변환 
									var latlon = new Tmapv2.Point(
										geometry.coordinates[0],
										geometry.coordinates[1]);
									// 포인트 객체를 받아 좌표값으로 다시 변환
									var convertPoint = new Tmapv2.Projection.convertEPSG3857ToWGS84GEO(
										latlon);

									var routeInfoObj = {
										markerImage: markerImg,
										lng: convertPoint._lng,
										lat: convertPoint._lat,
										pointType: pType
									};

									// Marker 추가
									addMarkers(routeInfoObj);
								}
							}//for문 [E]

						},
						error: function (request, status, error) {
							console.log("code:"
								+ request.status + "\n"
								+ "message:"
								+ request.responseText
								+ "\n" + "error:" + error);
						}
					});
					return transportData;

				}//end getTransportInfoBetweenPlaces


			}//end main


			function addComma(num) {
				var regexp = /\B(?=(\d{3})+(?!\d))/g;
				return num.toString().replace(regexp, ',');
			}

			//마커 생성하기
			function addMarkers(infoObj) {
				var size = new Tmapv2.Size(24, 38);//아이콘 크기 설정합니다.

				if (infoObj.pointType == "P") { //포인트점일때는 아이콘 크기를 줄입니다.
					size = new Tmapv2.Size(0, 0);
				}

				marker_p = new Tmapv2.Marker({
					position: new Tmapv2.LatLng(infoObj.lat, infoObj.lng),
					icon: infoObj.markerImage,
					iconSize: size,
					map: map
				});

				resultMarkerArr.push(marker_p);
			}

			//도보 라인 그리기
			function drawLine(arrPoint) {
				var polyline_;

				polyline_ = new Tmapv2.Polyline({
					path: arrPoint,
					strokeColor: "#DD0000",
					strokeWeight: 6,
					map: map
				});
				resultdrawArr.push(polyline_);
			}

			//라인그리기
			function drawLine(arrPoint, traffic) {
				var polyline_;
				console.log("라인 그리기");

				if (chktraffic.length != 0) {

					// 교통정보 혼잡도를 체크
					// strokeColor는 교통 정보상황에 다라서 변화
					// traffic :  0-정보없음, 1-원활, 2-서행, 3-지체, 4-정체  (black, green, yellow, orange, red)

					var lineColor = "";

					if (traffic != "0") {
						if (traffic.length == 0) { //length가 0인것은 교통정보가 없으므로 검은색으로 표시

							lineColor = "#06050D";
							//라인그리기[S]
							polyline_ = new Tmapv2.Polyline({
								path: arrPoint,
								strokeColor: lineColor,
								strokeWeight: 6,
								map: map
							});
							resultdrawArr.push(polyline_);
							//라인그리기[E]
						} else { //교통정보가 있음

							if (traffic[0][0] != 0) { //교통정보 시작인덱스가 0이 아닌경우
								var trafficObject = "";
								var tInfo = [];

								for (var z = 0; z < traffic.length; z++) {
									trafficObject = {
										"startIndex": traffic[z][0],
										"endIndex": traffic[z][1],
										"trafficIndex": traffic[z][2],
									};
									tInfo.push(trafficObject)
								}

								var noInfomationPoint = [];

								for (var p = 0; p < tInfo[0].startIndex; p++) {
									noInfomationPoint.push(arrPoint[p]);
								}

								//라인그리기[S]
								polyline_ = new Tmapv2.Polyline({
									path: noInfomationPoint,
									strokeColor: "#06050D",
									strokeWeight: 6,
									map: map
								});
								//라인그리기[E]
								resultdrawArr.push(polyline_);

								for (var x = 0; x < tInfo.length; x++) {
									var sectionPoint = []; //구간선언

									for (var y = tInfo[x].startIndex; y <= tInfo[x].endIndex; y++) {
										sectionPoint.push(arrPoint[y]);
									}

									if (tInfo[x].trafficIndex == 0) {
										lineColor = "#06050D";
									} else if (tInfo[x].trafficIndex == 1) {
										lineColor = "#61AB25";
									} else if (tInfo[x].trafficIndex == 2) {
										lineColor = "#FFFF00";
									} else if (tInfo[x].trafficIndex == 3) {
										lineColor = "#E87506";
									} else if (tInfo[x].trafficIndex == 4) {
										lineColor = "#D61125";
									}

									//라인그리기[S]
									polyline_ = new Tmapv2.Polyline({
										path: sectionPoint,
										strokeColor: lineColor,
										strokeWeight: 6,
										map: map
									});
									//라인그리기[E]
									resultdrawArr.push(polyline_);
								}
							} else { //0부터 시작하는 경우

								var trafficObject = "";
								var tInfo = [];

								for (var z = 0; z < traffic.length; z++) {
									trafficObject = {
										"startIndex": traffic[z][0],
										"endIndex": traffic[z][1],
										"trafficIndex": traffic[z][2],
									};
									tInfo.push(trafficObject)
								}

								for (var x = 0; x < tInfo.length; x++) {
									var sectionPoint = []; //구간선언

									for (var y = tInfo[x].startIndex; y <= tInfo[x].endIndex; y++) {
										sectionPoint.push(arrPoint[y]);
									}

									if (tInfo[x].trafficIndex == 0) {
										lineColor = "#06050D";
									} else if (tInfo[x].trafficIndex == 1) {
										lineColor = "#61AB25";
									} else if (tInfo[x].trafficIndex == 2) {
										lineColor = "#FFFF00";
									} else if (tInfo[x].trafficIndex == 3) {
										lineColor = "#E87506";
									} else if (tInfo[x].trafficIndex == 4) {
										lineColor = "#D61125";
									}
									//라인그리기[S]
									polyline_ = new Tmapv2.Polyline({
										path: sectionPoint,
										strokeColor: lineColor,
										strokeWeight: 6,
										map: map
									});
									//라인그리기[E]
									resultdrawArr.push(polyline_);
								}
							}
						}
					} else {

					}
				} else {
					polyline_ = new Tmapv2.Polyline({
						path: arrPoint,
						strokeColor: "#DD0000",
						strokeWeight: 6,
						map: map
					});
					resultdrawArr.push(polyline_);
				}
			}

			//초기화 기능
			function resettingMap() {
				//기존마커는 삭제
				marker_s.setMap(null);
				marker_e.setMap(null);

				if (resultMarkerArr.length > 0) {
					for (var i = 0; i < resultMarkerArr.length; i++) {
						resultMarkerArr[i].setMap(null);
					}
				}

				if (resultdrawArr.length > 0) {
					for (var i = 0; i < resultdrawArr.length; i++) {
						resultdrawArr[i].setMap(null);
					}
				}
				chktraffic = [];
				drawInfoArr = [];
				resultMarkerArr = [];
				resultdrawArr = [];
			}
		</script>
	</head>
<div class="container">
	<div class="input-form-backgroud row">
			<div class="input-form col-md-12 mx-auto">
	<body onload="initTmap()">
		<div id="sidebar">
			<!--
				<button id="showCalendarBtn">여행 시작일 : 2024-04-08</button>
				<div id="calendar">
					<input type="date" id="selectedDate">
					<button id="closeCalendarBtn">닫기</button>
				</div> -->

			<!-- 여행 기간 표시 영역 
				<div id="selectedDuration"></div>  -->



			<div id="routeName">
				<input type="text" id="routeNameInput" placeholder="여행 경로 이름 입력">
				<button id="editRouteNameButton">수정</button>
			</div>

		</div>

		<div id="smallScreen">
			<div id="placeName"></div>
			<div id="placeDescription"></div>
			<button id="addToSidebarButton">Add to Sidebar</button>
		</div>

		<!-- 맵 생성 실행 -->
		<div id="map_wrap" class="map_wrap">
			<div id="map_div"></div>
		</div>
		<div class="map_result">
		</div>
		<br />
		<div id="button_container">
			<button id="saveItineraryButton" class="savebutton">여행 일정 수정</button>
			<button id="addTour" onclick="toggleAddTour()">여행지 추가</button>
		</div>
		<!--마커가 찍힌곳에 여행지로 등록하기-->
		<div id="addTourScreen">
			<div>
				<h1>여행지 목록에 추가 하시겠습니까?</h1>
			</div>
			<button id="addToTourVO">추가</button>
			<button id="cancelToTourVO">취소</button>
		</div>

		<div class="modal fade" id="exampleModal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
			<div class="modal-dialog">
				<div class="modal-content">
					<div class="modal-header">
						<h5 class="modal-title" id="exampleModalLabel">New message</h5>
						<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>

					</div>
					<div class="modal-body">
						<form class="validation-form" id="addTourForm" action="/route/tourInsertOK" method="post">
							<div class="mb-3">
								<label for="tourName" class="col-form-label">여행지 이름:</label>
								<input type="text" class="form-control" id="tourName" name="tourName">
							</div>
							<div class="mb-3">
								<label for="tourAddress" class="col-form-label">여행지 주소:</label>
								<input type="text" class="form-control" id="tourAddress" name="tourAddress"
									value="경남 창원시 의창구 대산면 가술리">
							</div>
							<div class="mb-3">
								<label for="tourContent" class="col-form-label">여행지 설명:</label>
								<textarea class="form-control" id="tourContent" name="tourContent"
									value="주남돌다리도 두드려보고 건너자"></textarea>
							</div>
							<div class="mb-3">
								<label for="tourTel" class="col-form-label">여행지 연락처(선택):</label>
								<input type="text" class="form-control" id="tourTel" name="tourTel">
							</div>
							<div class="mb-3">
								<label for="tourImg" class="col-form-label">이미지 URL:</label>
								<input type="file" class="form-control" id="tourImg" name="tourImg">
							</div>
							<!-- 경도와 위도는 숨겨진 필드로 자동으로 설정됩니다 -->
							<input type="hidden" id="longtitue" name="longtitue">
							<input type="hidden" id="lattitue" name="lattitue">
						</form>
					</div>
					<div class="modal-footer">
						<button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
						<button id="addGuideToTourBtn" type="submit" class="btn btn-primary">Send message</button>
					</div>
				</div>
			</div>
		</div>
		<!--모달: 여행지 추가 form end-->
		<script>
			$("#addGuideToTourBtn").click(function () {
				console.log("send message click");
				addTourForm.submit();
			});
		</script>

	</body>
	</div>
	</div>
		</div>
</div>

</html>